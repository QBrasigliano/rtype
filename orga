Jour 1 : Setup & Infrastructure ✅
✅ Structure dossiers finalisée (engine/, server/, client/, assets/)
✅ CMakeLists.txt pour chaque dossier
✅ Conan + dépendances (Raylib 5.0, ASIO 1.28.0)
✅ CMake optimisé macOS (14 cœurs, LTO, SIMD)
✅ Alias 'rtype-build' fonctionnel
✅ Compilation sans erreurs

Jour 2 : Protocole & Networking ✅
✅ 3.1 Protocol.hpp/cpp
   ✅ Struct Packet + Enums (InputType)
   ✅ CalculateChecksum() + IsValid()
   ✅ Serialize() (Packet → bytes, big-endian)
   ✅ Deserialize() (bytes → Packet avec validation)
   ✅ Checksum 16-bit validation
   ✅ Test: ✅ Test OK!

✅ 3.2 NetworkManager.hpp/cpp (SERVEUR)
   ✅ Sockets TCP ASIO avec async_accept
   ✅ Accepter connexions clients multiples
   ✅ async_read en boucle sur chaque socket
   ✅ Recevoir et désérialiser paquets clients
   ✅ Gestion erreurs réseau (EOF = client déconnecté)
   ✅ ID client unique (next_client_id_, incrémental)
   ✅ Messages: "Client ID: X connecté/déconnecté"

✅ 4.1 Client.hpp/cpp (CLIENT)
   ✅ Classe Client avec async_connect
   ✅ Se connecter au serveur (127.0.0.1:4242)
   ✅ SendPacket() avec async_write
   ✅ Update() pour traiter événements ASIO
   ✅ Disconnect() propre

✅ 4.2 Client GUI (main.cpp)
   ✅ Fenêtre Raylib 1024x768
   ✅ Cercle bleu contrôlable (flèches)
   ✅ Limites écran
   ✅ Fonctions raccourcies: SendMovementPacket(), HandleInput(), Render()
   ✅ Timer 100ms pour envoyer inputs au serveur
   ✅ Envoie MOVE_UP/DOWN/LEFT/RIGHT

Jour 3 : Multiplayer Networking ✅
✅ 3.3 ClientRegistry.hpp/cpp
   ✅ Gestion clients connectés sur serveur
   ✅ Mapping client ID ↔ socket avec shared_ptr
   ✅ SendToAll() + SendToAllExcept() pour broadcasts
   ✅ AddClient() avec spawn broadcasting
   ✅ RemoveClient() avec cleanup automatique

✅ 3.4 Position Synchronization
   ✅ Server reçoit paquets MOVE_* des clients
   ✅ Server extrait positions absolues (X, Y)
   ✅ Server broadcast PLAYER_MOVED à tous autres clients
   ✅ Format paquet: client_id(1) + X(2) + Y(2) = 5 bytes
   ✅ Big-endian encoding pour cross-platform

✅ 3.5 Client Reception System
   ✅ ReadServerMessage() avec async_read recursif
   ✅ Désérialisation paquets PLAYER_MOVED
   ✅ Callback system: SetOnPlayerMoved(callback)
   ✅ Affichage autres joueurs en ROUGE (toi en BLEU)
   ✅ Compteur joueurs connectés dynamique

✅ 3.6 Connection Management
   ✅ Détection déconnexion server → fermeture auto client
   ✅ Validation connexion avant lancement graphiques
   ✅ Gestion erreurs robuste (Connection reset by peer)
   ✅ Spawn synchronisé: tous joueurs à (100, 400)

✅ 3.7 Real-time Multiplayer
   ✅ 60 FPS sync client-serveur
   ✅ Mouvements temps réel sans lag
   ✅ Broadcast filtering (pas de self-reception)
   ✅ Position initiale broadcast au spawn
   ✅ Test: ✅ 2+ clients se voient bouger en temps réel!

Jour 4 : Gameplay Core 
✅ 4.1 Tir/Projectiles - COMPLET
   ✅ SHOOT packet type + handling  
   ✅ Bullet entity avec lifetime et position/vélocité
   ✅ Broadcast tirs aux autres clients (BULLET_SPAWNED)
   ✅ Affichage projectiles synchronisé (cercles jaunes)
   ✅ Mouvement bullets temps réel (300px/s vers droite)
   ✅ Suppression bullets hors écran/expirées  
   ✅ Système complet client-serveur fonctionnel
   ✅ Commentaires explicatifs sur tous les if statements
   ✅ Test: ✅ Tir avec ESPACE = bullets volent vers la droite!

Jour 5 : ECS
- Entity.hpp + World.hpp
- PositionComponent, VelocityComponent
- Migration Player + Bullets vers ECS
- RenderSystem simple (cercles)

Jour 6 : Ennemis + Mouvement
- EnemyComponent 
- ENEMY_SPAWNED packet type
- Spawn ennemis côté serveur (cercles rouges)
- Mouvement droit (gauche→droite)
- Networking ennemis

Jour 7 : Collisions + Gameplay
- CollisionSystem (bullets vs ennemis)
- Destruction entities sur collision
- Score basique (+10 par ennemi tué)
- Game Over si joueur touché

Jour 8 : Polish Final
- Affichage score/vies
- Nettoyage code
- Test final complet


2 commit par jour
client doit dégager (complétement refaire)
savoir tout expliquer le système de templating niveau basique (Live code)
 