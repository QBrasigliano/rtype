Jour 1 : Setup & Infrastructure ✅
✅ Structure dossiers finalisée (engine/, server/, client/, assets/)
✅ CMakeLists.txt pour chaque dossier
✅ Conan + dépendances (Raylib 5.0, ASIO 1.28.0)
✅ CMake optimisé macOS (14 cœurs, LTO, SIMD)
✅ Alias 'rtype-build' fonctionnel
✅ Compilation sans erreurs

Jour 2 : Protocole & Networking ✅
✅ 3.1 Protocol.hpp/cpp
   ✅ Struct Packet + Enums (InputType)
   ✅ CalculateChecksum() + IsValid()
   ✅ Serialize() (Packet → bytes, big-endian)
   ✅ Deserialize() (bytes → Packet avec validation)
   ✅ Checksum 16-bit validation
   ✅ Test: ✅ Test OK!

✅ 3.2 NetworkManager.hpp/cpp (SERVEUR)
   ✅ Sockets TCP ASIO avec async_accept
   ✅ Accepter connexions clients multiples
   ✅ async_read en boucle sur chaque socket
   ✅ Recevoir et désérialiser paquets clients
   ✅ Gestion erreurs réseau (EOF = client déconnecté)
   ✅ ID client unique (next_client_id_, incrémental)
   ✅ Messages: "Client ID: X connecté/déconnecté"

✅ 4.1 Client.hpp/cpp (CLIENT)
   ✅ Classe Client avec async_connect
   ✅ Se connecter au serveur (127.0.0.1:4242)
   ✅ SendPacket() avec async_write
   ✅ Update() pour traiter événements ASIO
   ✅ Disconnect() propre

✅ 4.2 Client GUI (main.cpp)
   ✅ Fenêtre Raylib 1024x768
   ✅ Cercle bleu contrôlable (flèches)
   ✅ Limites écran
   ✅ Fonctions raccourcies: SendMovementPacket(), HandleInput(), Render()
   ✅ Timer 100ms pour envoyer inputs au serveur
   ✅ Envoie MOVE_UP/DOWN/LEFT/RIGHT

Jour 3 : En cours
⏳ 3.3 ClientRegistry.hpp
   ⏳ Gestion clients connectés sur serveur
   ⏳ Mapping client ID ↔ socket
   ⏳ Stockage des données joueur
⏳ 3.4 GameLogic.hpp
   ⏳ Entités (joueur, ennemis, bullets)
   ⏳ Spawn/despawn logique
   ⏳ Collision détection (AABB)
⏳ 3.5 Server Main Loop
   ⏳ Boucle serveur principale
   ⏳ Coordonner NetworkManager + GameLogic
   ⏳ Broadcast état du jeu aux clients

Jour 4 : Engine - ECS Architecture
⏳ 2.1 Entity.hpp/cpp
   ⏳ Classe Entity (ID, liste components)
   ⏳ GetComponent<T>() / AddComponent<T>()
   ⏳ RemoveComponent<T>()
⏳ 2.2 Component.hpp
   ⏳ Classe abstraite Component
   ⏳ Components: Position, Velocity, Sprite, Health
⏳ 2.3 World.hpp/cpp
   ⏳ Gestionnaire d entités
   ⏳ Spawn/Destroy entités
   ⏳ Gestion des systems
⏳ 2.4 Engine.hpp/cpp
   ⏳ Boucle de jeu (Input → Update → Render)
   ⏳ Delta time
   ⏳ Fenêtre Raylib

Jour 4 : Client - Renderer & Input
⏳ 4.1 RenderSystem.hpp/cpp
   ⏳ Afficher les sprites
   ⏳ Gestion caméra
   ⏳ HUD basique (debug)
⏳ 4.2 InputHandler.hpp/cpp
   ⏳ Clavier/souris input
   ⏳ Convertir en actions
⏳ 4.3 Client.hpp/cpp
   ⏳ Connexion au serveur
   ⏳ Recevoir état du jeu
   ⏳ Affichage synchronisé
⏳ 4.4 UI Menu
   ⏳ Écran de démarrage
   ⏳ Sélection serveur

Jour 5 : Physique & Collisions
⏳ 5.1 PhysicsSystem.hpp/cpp
   ⏳ Mouvement (pos += vel * dt)
   ⏳ Limite écran
⏳ 5.2 CollisionSystem.hpp/cpp
   ⏳ AABB collision detection
   ⏳ Callback collisions
⏳ 5.3 Player.hpp/cpp
   ⏳ Classe joueur (hérité Entity)
   ⏳ Déplacement (WASD)
⏳ 5.4 Enemy.hpp/cpp
   ⏳ Classe ennemi basique
   ⏳ Mouvement simple

Jour 6 : Gameplay - Tir & Spawn
⏳ 6.1 Bullet.hpp/cpp
   ⏳ Classe projectile
   ⏳ Destruction hors écran
⏳ 6.2 EnemySpawner.hpp/cpp
   ⏳ Spawn vagues d ennemis
   ⏳ Gestion timing
⏳ 6.3 Player Shoot
   ⏳ Tir avec barre espace
   ⏳ Cooldown
⏳ 6.4 Destruction
   ⏳ Collision bullet → ennemi
   ⏳ Gestion mort ennemi

Jour 7 : Polish & Assets
⏳ 7.1 Sprites
   ⏳ Charger assets/textures/
   ⏳ Joueur, ennemis, bullets
⏳ 7.2 Score & UI
   ⏳ Affichage score
   ⏳ Compteur vies
⏳ 7.3 Sounds (optionnel)
   ⏳ Charger assets/sounds/
   ⏳ Tir, explosion
⏳ 7.4 Game Over
   ⏳ Écran fin de partie

Jour 8 : Testing & Debug
⏳ 8.1 Tests unitaires
   ⏳ Protocol tests
   ⏳ Collision tests
⏳ 8.2 Debug réseau
   ⏳ Vérifier paquets
   ⏳ Latence
⏳ 8.3 Performance
   ⏳ Profiler
   ⏳ Optimisations
⏳ 8.4 Bugfix
   ⏳ Fixer issues critiques
   ⏳ Polish gameplay


Reception des inputs joueur
Ou : Garder tout en single-player si trop complexe
Objectif : Multi-joueur OU single-player stable

Jour 9 : Polish & Assets
Sprites/couleurs pour joueur, ennemis, bullets
SFX/musique (simple)
Menu simple (Start/Quit)
Écran Game Over
Objectif : Jeu "fini" visuellement

Jour 10 : Tests & Bugfix
Tester tout le gameplay
Fixer bugs critiques
Optimisations si besoin
Nettoyage code
Objectif : Jeu fonctionnel et stable